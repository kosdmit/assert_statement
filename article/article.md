# Почему вы не должны использовать оператор `assert` в Python.

Привет! Меня зовут Дмитрий, я python backend-разработчик. В текущем проекте на Python мы отказались от использования выражений с ключевым словом `assert`, и в этой статье я расскажу почему.

## Немного базы

Ключевое слово `assert` было впервые добавлено в язык ещё в версии 1.5, с тех пор оно широко используется несмотря на ограничения, о которых мы поговорим позже.

Синтаксис выражения не претерпел изменений с момента введения и имеет следующий вид: `assert <condition>` или `assert <condition>, <errormessage>`. При использовании `assert`, Python проверяет условие, а в случае его невыполнения вызывает `AssertionError`. Это эквивалентно следующему коду:

```python
if not expression: 
    raise AssertionError
```

Убедимся в этом, проанализировав дизассемблированный байт-код для простого выражения:

```python
>>> dis.dis('assert 1 == 0')
  0           0 RESUME                   0

  1           2 LOAD_CONST               0 (1)
              4 LOAD_CONST               1 (0)
              6 COMPARE_OP              40 (==)
             10 POP_JUMP_IF_TRUE         2 (to 16)
             12 LOAD_ASSERTION_ERROR
             14 RAISE_VARARGS            1
        >>   16 RETURN_CONST             2 (None)
```

Хотя исключение AssertionError не несёт семантического смысла, выражение assert широко используется как более короткий и лаконичный способ записи выражения выше (синтаксический сахар).

Например, валидаторы [Pydantic](https://docs.pydantic.dev/latest/concepts/validators/#field-validators) могут бросать AssertionError если полученные данные не валидны, при этом допускается использование выражения `assert`:

```python
def check_alphanumeric(cls, v: str, info: ValidationInfo) -> str:
    if isinstance(v, str):
        # info.field_name is the name of the field being validated
        is_alphanumeric = v.replace(' ', '').isalnum()
        assert is_alphanumeric, f'{info.field_name} must be alphanumeric'
    return v
```

*В качестве примера приведен код из документации pydantic*

## Подводные камни

Интересно, что, выражение `assert`, согласно [документации](https://docs.python.org/3.6/reference/simple_stmts.html#assert) аналогично коду, который отличается от приведённого выше:

```python
if __debug__:
  if not expression: raise AssertionError
```

или

```python
if __debug__:
    if not expression1: raise AssertionError(expression2)
```

Видно, что проверка условия внутри `assert` дополнительно обёрнута в условие `if __debug__:`. Таким образом, выражения `assert` выполняются только в случае, если условие `if __debug__` истинно.

Такая деталь часто не принимается во внимание, ведь `__debug__` - это build-in переменная python, которая в большинстве случаев принимает значение `True`. Да, запуская любой python код с помощью команды `python main.py` в командной строке, фактически вы запускаете python-код в режиме дебага! Изменение значения переменной `__debug__` в рантайме python [запрещено](https://docs.python.org/3.6/reference/simple_stmts.html#assert), а единственный легальный способ присвоить этой переменной значение `False` - запускать интерпретатор с флагом `-O` или `-OO`.

Флаг `-O` (Optimize) изменяет значение переменной `__debug__` на `False`. Как следствие, все выражения `assert` игнорируются в процессе компиляции байт-кода. Это позволяет немного снизить размер `.pyo` файлов и не производить "лишних" вычислений.

Фактически запуск интерпретатора в optimized режиме изменяет поведение вашей программы. Например, приведённый выше валидатор pydantic просто перестаёт работать! Согласитесь, неочевидное поведение. Такой баг бывает сложно отловить, т.к. запуская тот же исходный код в другом окружении, вы получаете абсолютно корректную работу.

Кроме того, если вычисление выражения внутри конструкции `assert` подразумевает выполнение функции с побочными эффектами (например запись в лог) то эти действия также не будут выполнены. Строка кода содержащая выражение `assert` игнорируется.

## Как быть

Таким образом, выражение `assert` имеет неявное поведение, зависящее от окружения в котором выполняется код. Можно, учитывая всё описанное выше, контролировать использование `assert`, отслеживая побочные эффекты, или условиться не использовать optimized режим интерпретатора. Но если существует хоть малейшая вероятность негативного события, то на большой дистанции нельзя гарантировать что оно не произойдёт.

Нельзя наверняка знать, в каком окружении будет запущен ваш код (использование флага `-O` в продакшен окружении - широкая практика). Поэтому, серебряная пуля - отказаться от использования `assert` в вашем коде. Тем более что, сообщество python придерживается такого же мнения - в [ruff](https://docs.astral.sh/ruff/rules/assert/) уже есть соответствующее правило, которое изначально было добавлено в пакете [flake8-bandit](https://pypi.org/project/flake8-bandit/).

Тогда пример с валидатором из документации pydantic будет выглядить следующим образом:

```python
def check_alphanumeric(cls, v: str, info: ValidationInfo) -> str:
    if isinstance(v, str):
        # info.field_name is the name of the field being validated
        is_alphanumeric = v.replace(' ', '').isalnum()
        if not is_alphanumeric:
            raise ValueError(f'{info.field_name} must be alphanumeric')
    return v
```

Pydantic позволяет использовать оба варианта - с использованием `assert` или `raise ValueError`. При этом, `assert` не будет работать в optimized режиме, о чем документация pydantic почему-то умалчивает.

## Заключение

В этой статье я сделал упор на особенности работы интерпретатора с включенном или отключенным флагом `-O`. Хотя это не единственный минус безконстрольного использования выражений `assert`. Стоит также отметить что, Assert

В заключение хочу порекомендовать всегда использовать линтеры в ваших проектах на python. Линтеры помогут автоматически находить использование `assert` и предотвращать появления множества других ошибок. На данный момент ruff содержит более 800 встроенных правил, которые основаны на обобщённом опыте сообщества python. Запуская линтеры в CI пайплайне или локально через pre-commit, вы снизите риск появления сложно отлавливаемых багов и повысите качество кода в целом. Удачи!
